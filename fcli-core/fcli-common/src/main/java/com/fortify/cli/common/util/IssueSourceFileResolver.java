/**
 * Copyright 2023 Open Text.
 *
 * The only warranties for products and services of Open Text 
 * and its affiliates and licensors ("Open Text") are as may 
 * be set forth in the express warranty statements accompanying 
 * such products and services. Nothing herein should be construed 
 * as constituting an additional warranty. Open Text shall not be 
 * liable for technical or editorial errors or omissions contained 
 * herein. The information contained herein is subject to change 
 * without notice.
 */
package com.fortify.cli.common.util;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.formkiq.graalvm.annotations.Reflectable;

import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;

/**
 * <p>Due to the way that Fortify packages and scans code, source file paths returned by FoD and SSC
 * may not exactly match original source file paths. In some cases, a leading path may be added
 * by Fortify, like /scancentral12345678/work/..., whereas in other cases, leading paths may be
 * stripped, like removing src/main/java from a path like src/main/java/my/pkg/Class.java</p>
 * 
 * <p>This may lead to user confusion, and may cause issues when importing reports generated by
 * fcli actions like gitlab-sast-report or github-sast-report into the respective 3rd-party systems, 
 * as these systems will then be unable to match the file path on which an issue is being reported
 * against an actual repository path.</p>
 * 
 * <p>To work around these issues, this class attempts to map Fortify-provided issue source file 
 * paths against local file system paths relative to a given source code directory, basically 
 * finding the longest matching path suffix.</p>
 *  
 * @author Ruud Senden
 */
// TODO Also see TODO comments in IssueSourceFileResolverTest
// TODO How to handle absolute paths? Always return as-is (or null if not existing and OnNoMatch.NULL)? Or try to resolve against sourcePath?
// TODO How to handle drive letters (with either absolute or relative path)?
@Builder @Reflectable
public class IssueSourceFileResolver {
    private static final Logger LOG = LoggerFactory.getLogger(IssueSourceFileResolver.class);
    @Getter private final Path sourcePath;
    @Builder.Default private final OnNoMatch onNoMatch = OnNoMatch.ORIGINAL;
    @Builder.Default private final FileSeparator separatorOnReturn = FileSeparator.LINUX;
    private final AtomicReference<SourceFileIndex> indexReference = new AtomicReference<>();
    
    /**
     * Find the given {@link Path} in the configured source path. Based on the Fortify behavior
     * described in the class description, if the configured source path contains a single file 
     * <code>src/main/java/com/fortify/X.java</code>, this method will return a relative {@link Path} 
     * representing <code>src/main/java/com/fortify/X.java</code> for each of the following input paths:
     * <ul>
     *  <li><code>scancentral123/work/src/main/java/com/fortify/X.java</code></li>
     *  <li><code>any/leading/dir/src/main/java/com/fortify/X.java</code></li>
     *  <li><code>src/main/java/com/fortify/X.java</code></li>
     *  <li><code>main/java/com/fortify/X.java</code></li>
     *  <li><code>java/com/fortify/X.java</code></li>
     *  <li><code>com/fortify/X.java</code></li>
     *  <li><code>fortify/X.java</code></li>
     *  <li><code>X.java</code></li>
     * </ul>
     * Any other input path will be considered a non-matching path, in which case either the given 
     * path or <code>null</code> will be returned, based on the configured {@link OnNoMatch} setting.
     * In particular, note that if the given path includes a leading directory, it will only match
     * if any of its sub-paths match the full relative source path. With the example above, this
     * means that <code>scancentral123/work/com/fortify/X.java</code> will be considered non-matching,
     * as it lacks the <code>src/main/java</code> path.
     */
    public final Path resolve(Path issuePath) {
        var result = indexReference.updateAndGet(this::createIndexIfNull).resolve(issuePath);
        if ( result!=null && LOG.isTraceEnabled() ) { LOG.trace("Resolved issue path {} to source path {}", issuePath, result); }
        if ( result==null && onNoMatch==OnNoMatch.ORIGINAL ) {
            result = issuePath;
        }
        return result;
    }
    
    /**
     * This is the {@link String}-based variant of {@link #resolve(Path)}:
     * <ol>
     *  <li>Convert the given {@link String} into a {@link Path} instance</li>
     *  <li>Call the {@link #resolve(Path)} method to find this path in the configured source path</li>
     *  <li>Convert the {@link Path} instance returned by {@link #resolve(Path)} into a {@link String},
     *      using the configured {@link #separatorOnReturn} file separator.</li>
     * </ol>
     */
    public final String resolve(String issuePath) {
        return FileUtils.pathToString(resolve(Path.of(issuePath)), separatorOnReturn.getSeparatorChar());
    }
    
    private final SourceFileIndex createIndexIfNull(SourceFileIndex index) {
        if ( index==null ) {
            index = new SourceFileIndex(sourcePath);
        }
        return index;
    }
    
    public static enum OnNoMatch {
        NULL, ORIGINAL
    }
    
    @RequiredArgsConstructor
    public static enum FileSeparator {
        LINUX('/'), WINDOWS('\\'), PLATFORM(File.separatorChar);
        
        @Getter private final char separatorChar;
    }
    
    private static final class SourceFileIndex {
        /** Full relative paths, like src/main/java/com/fortify/X.java */
        private final Map<String,Path> fullRelativePathsIndex;
        /** Full and partial relative paths, like src/main/java/com/fortify/X.java, com/fortify/X.java, X.java */ 
        private final Map<String,Path> fullAndPartialRelativePathsIndex;
        
        private SourceFileIndex(Path sourcePath) {
            this.fullRelativePathsIndex = createFullRelativePathsIndex(sourcePath);
            this.fullAndPartialRelativePathsIndex = createFullAndPartialRelativePathsIndex(fullRelativePathsIndex.values());
        }
        
        /**
         * <p>This method first tries to match the given path against {@link #fullAndPartialRelativePathsIndex}, which, given a 
         * source path <code>src/main/java/com/fortify/X.java</code>, will match each of the following input paths:
         * <code>X.java</code>, <code>com/fortify/X.java</code>, and <code>src/main/java/com/fortify/X.java</code>. This handles 
         * situations where Fortify strips leading directories.</p>
         * 
         * <p>If no match is found in {@link #fullAndPartialRelativePathsIndex}, this method will then attempt to match any of 
         * the sub-paths in the given path against {@link #fullRelativePathsIndex}, which, given a source path
         * <code>src/main/java/com/fortify/X.java</code>, will match an input path like 
         * <code>any/leading/dir/src/main/java/com/fortify/X.java</code>, but not <code>any/leading/dir/com/fortify/X.java</code>.</p> 
         */
        protected final Path resolve(Path path) {
            var normalizedPath = path.normalize();
            var result = fullAndPartialRelativePathsIndex.get(pathToString(normalizedPath));
            return result!=null ? result : resolveSubPathFromFullRelativePathsIndex(path);
        }

        private Path resolveSubPathFromFullRelativePathsIndex(Path normalizedPath) {
            var result = fullRelativePathsIndex.get(pathToString(normalizedPath));
            if ( result==null ) {
                var nameCount = normalizedPath.getNameCount();
                if ( nameCount > 1 ) {
                    return resolveSubPathFromFullRelativePathsIndex(normalizedPath.subpath(1, nameCount));
                }
            }
            return result;
        }

        @SneakyThrows
        private static final Map<String, Path> createFullRelativePathsIndex(Path sourcePath) {
            var result = new HashMap<String, Path>();
            if ( sourcePath!=null && Files.isDirectory(sourcePath) ) {
                var normalizedSourcePath = sourcePath.normalize();
                try (Stream<Path> stream = Files.walk(normalizedSourcePath)) {
                    stream.filter(Files::isRegularFile)
                          .forEach(p->addPathToFullRelativePathsIndex(result, normalizedSourcePath.relativize(p.normalize())));
                }
            }
            return result;
        }

        private static final void addPathToFullRelativePathsIndex(Map<String, Path> result, Path fullRelativePath) {
            if ( LOG.isTraceEnabled() ) { LOG.trace("Adding source path {} to index", fullRelativePath); }
            result.put(pathToString(fullRelativePath), fullRelativePath);
        }
        
        private static final Map<String, Path> createFullAndPartialRelativePathsIndex(Collection<Path> fullRelativePaths) {
            var result = new HashMap<String, Path>();
            fullRelativePaths.forEach(p->addPathToFullAndPartialRelativePathsIndex(result, p, p));
            return result;
        }
        
        private static final void addPathToFullAndPartialRelativePathsIndex(Map<String, Path> index, Path fullRelativePath, Path partialRelativePath) {
            index.put(pathToString(partialRelativePath), fullRelativePath);
            var nameCount = partialRelativePath.getNameCount(); 
            if ( nameCount > 1 ) {
                addPathToFullAndPartialRelativePathsIndex(index, fullRelativePath, partialRelativePath.subpath(1, nameCount));
            }
        }
        
        private static final String pathToString(Path normalizedPath) {
            return FileUtils.pathToString(normalizedPath, '/');
        }
    }
}
