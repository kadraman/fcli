/**
 * Copyright 2023 Open Text.
 *
 * The only warranties for products and services of Open Text 
 * and its affiliates and licensors ("Open Text") are as may 
 * be set forth in the express warranty statements accompanying 
 * such products and services. Nothing herein should be construed 
 * as constituting an additional warranty. Open Text shall not be 
 * liable for technical or editorial errors or omissions contained 
 * herein. The information contained herein is subject to change 
 * without notice.
 */
package com.fortify.cli.common.action.runner;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.springframework.expression.spel.support.SimpleEvaluationContext;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.formkiq.graalvm.annotations.Reflectable;
import com.fortify.cli.common.action.model.ActionConfig.ActionConfigOutput;
import com.fortify.cli.common.action.model.ActionStepCheckEntry;
import com.fortify.cli.common.action.model.ActionStepCheckEntry.CheckStatus;
import com.fortify.cli.common.action.model.FcliActionValidationException;
import com.fortify.cli.common.action.runner.processor.IActionRequestHelper;
import com.fortify.cli.common.json.JsonHelper;
import com.fortify.cli.common.output.writer.record.IRecordWriter;
import com.fortify.cli.common.progress.helper.IProgressWriterI18n;
import com.fortify.cli.common.spring.expression.IConfigurableSpelEvaluator;
import com.fortify.cli.common.spring.expression.ISpelEvaluator;
import com.fortify.cli.common.util.StringUtils;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.SneakyThrows;

/**
 * This class holds action execution context
 * @author Ruud Senden
 */
@Getter @Builder
public class ActionRunnerContext implements AutoCloseable {
    /** Jackson {@link ObjectMapper} used for various JSON-related operations */
    private final ObjectMapper objectMapper = JsonHelper.getObjectMapper();
    /** Action runner configuration, provided through builder method */
    private final ActionRunnerConfig config;
    /** Progress writer, provided through builder method */
    private final IProgressWriterI18n progressWriter;
    /** ObjectNode holding parameter values as generated by ActionParameterProcessor */
    private final ObjectNode parameterValues;
    /** Check statuses */
    private final Map<ActionStepCheckEntry, CheckStatus> checkStatuses = new LinkedHashMap<>(); 
    
    /** If output needs to be delayed (to not interfere with progress writer), these
     *  runnables will write the collected output. */
    private final List<Runnable> delayedConsoleWriterRunnables = new ArrayList<>();
    /** Save original stdout for delayed output operations */
    private final PrintStream orgStdout = System.out;
    /** Save original stderr for delayed output operations */
    private final PrintStream orgStderr = System.err;
    /** PrintStream for writing to stdout, either delayed or immediately depending on configuration */
    @Getter(lazy=true) private final PrintStream stdout = createImmediateOrDelayedPrintStream(orgStdout);
    /** PrintStream for writing to stderr, either delayed or immediately depending on configuration */
    @Getter(lazy=true) private final PrintStream stderr = createImmediateOrDelayedPrintStream(orgStderr);
    @Setter @Builder.Default private int exitCode = 0;
    @Setter @Builder.Default boolean exitRequested = false;
    
    /** Modifiable map with Request helpers; may be added during context configuration phase or action execution */
    private final Map<String, IActionRequestHelper> requestHelpers = new HashMap<>();
    /** Modifyable map with IActionStepWriter instances indexed by writer id */
    @Getter private final Map<String, IRecordWriter> writers = new HashMap<>();
    /** Factory for creating the single {@link ISpelEvaluator} instance. By using a factory, we can
     *  check for illegal access to the {@link ISpelEvaluator} during configuration phase. */
    @Getter(AccessLevel.NONE) private final ActionConfigSpelEvaluatorFactory spelEvaluatorFactory = new ActionConfigSpelEvaluatorFactory(this);
    
    public final ActionRunnerContext initialize() {
        config.getActionContextConfigurers().forEach(configurer->configurer.accept(this));
        return this;
    }
    
    public final void addRequestHelper(String name, IActionRequestHelper requestHelper) {
        getRequestHelpers().put(name, requestHelper);
    }
    
    public final IActionRequestHelper getRequestHelper(String name) {
        var requestHelpers = getRequestHelpers();
        if ( StringUtils.isBlank(name) ) {
            if ( requestHelpers.size()==1 ) {
                return requestHelpers.values().iterator().next();
            } else {
                throw new FcliActionValidationException(String.format("Required 'from:' property (allowed values: %s) missing", requestHelpers.keySet()));
            }
        } 
        var result = requestHelpers.get(name);
        if ( result==null ) {
            throw new FcliActionValidationException(String.format("Invalid 'from: %s', allowed values: %s", name, requestHelpers.keySet()));
        }
        return result;
    }
    
    public final IConfigurableSpelEvaluator getSpelEvaluator() {
        return spelEvaluatorFactory.getSpelEvaluator();
    }
    
    @RequiredArgsConstructor
    private static final class ActionConfigSpelEvaluatorFactory extends AbstractSpelEvaluatorFactory {
        private final ActionRunnerContext actionRunnerContext;
        
        protected final void configureSpelContext(SimpleEvaluationContext spelContext) {
            var config = actionRunnerContext.getConfig();
            configureSpelContext(spelContext, config.getActionConfigSpelEvaluatorConfigurers(), config);
            configureSpelContext(spelContext, config.getActionContextSpelEvaluatorConfigurers(), actionRunnerContext);
            spelContext.setVariable("action", new ActionUtil(actionRunnerContext));
        }
    }
    
    @Reflectable @RequiredArgsConstructor
    public static final class ActionUtil {
        private final ActionRunnerContext ctx;
        public final String copyParametersFromGroup(String group) {
            StringBuilder result = new StringBuilder();
            for ( var e : ctx.getConfig().getAction().getCliOptions().entrySet() ) {
                var name = e.getKey();
                var p = e.getValue();
                if ( group==null || group.equals(p.getGroup()) ) {
                    var val = ctx.getParameterValues().get(name);
                    if ( val!=null && StringUtils.isNotBlank(val.asText()) ) {
                        result
                          .append("\"--")
                          .append(name)
                          .append("=")
                          .append(val.asText())
                          .append("\" ");
                    }
                }
            }
            return result.toString();
        }
        
        public final JsonNode fmt(String formatterName, JsonNode input) {
            return ActionRunnerHelper.fmt(ctx, formatterName, input);
        }
    }
    
    public final boolean isDelayed() {
        // TODO Should we check progress writer as well here? 
        //      I.e., if simple progress writer, we don't need to delay output.
        return getConfig().getAction().getConfig().getOutput()==ActionConfigOutput.delayed;
    }
    
    private final PrintStream createImmediateOrDelayedPrintStream(PrintStream orgOut) {
        return isDelayed() ? createDelayedPrintStream(orgOut) : new NonClosingPrintStream(orgOut);
    }
    
    private final PrintStream createDelayedPrintStream(PrintStream orgOut) {
        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
        delayedConsoleWriterRunnables.add(()->orgOut.print(baos.toString()));
        return new PrintStream(baos, true);
    }

    @Override
    public void close() {
        getRequestHelpers().values().forEach(IActionRequestHelper::close);
    }
    
    private static final class NonClosingPrintStream extends PrintStream {
        public NonClosingPrintStream(OutputStream out) {
            super(out); 
        }
        
        @Override @SneakyThrows
        public void close() {
            out.flush();
            // Only flush, don't close underlying stream
        }
    }
}
