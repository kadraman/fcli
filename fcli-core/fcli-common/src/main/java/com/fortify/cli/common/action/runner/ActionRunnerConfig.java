/**
 * Copyright 2023 Open Text.
 *
 * The only warranties for products and services of Open Text 
 * and its affiliates and licensors ("Open Text") are as may 
 * be set forth in the express warranty statements accompanying 
 * such products and services. Nothing herein should be construed 
 * as constituting an additional warranty. Open Text shall not be 
 * liable for technical or editorial errors or omissions contained 
 * herein. The information contained herein is subject to change 
 * without notice.
 */
package com.fortify.cli.common.action.runner;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.springframework.expression.spel.support.SimpleEvaluationContext;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.BooleanNode;
import com.fasterxml.jackson.databind.node.DoubleNode;
import com.fasterxml.jackson.databind.node.FloatNode;
import com.fasterxml.jackson.databind.node.IntNode;
import com.fasterxml.jackson.databind.node.LongNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.TextNode;
import com.formkiq.graalvm.annotations.Reflectable;
import com.fortify.cli.common.action.model.Action;
import com.fortify.cli.common.action.model.ActionParameter;
import com.fortify.cli.common.action.runner.processor.IActionRequestHelper;
import com.fortify.cli.common.cli.util.SimpleOptionsParser.OptionsParseResult;
import com.fortify.cli.common.json.JsonHelper;
import com.fortify.cli.common.progress.helper.IProgressWriterFactory;
import com.fortify.cli.common.progress.helper.IProgressWriterI18n;
import com.fortify.cli.common.spring.expression.IConfigurableSpelEvaluator;
import com.fortify.cli.common.spring.expression.ISpelEvaluator;
import com.fortify.cli.common.spring.expression.SpelEvaluator;
import com.fortify.cli.common.spring.expression.SpelHelper;
import com.fortify.cli.common.util.StringUtils;

import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import picocli.CommandLine;

/**
 * This class holds action runner configuration
 * @author Ruud Senden
 */
@Builder @Getter
public class ActionRunnerConfig {
    /** Progress writer, provided through builder method */
    private final IProgressWriterFactory progressWriterFactory;
    /** Root CommandLine object for executing fcli commands, provided through builder method */
    private final CommandLine rootCommandLine;
    /** Data extract action, provided through builder method */
    private final Action action;
    /** Callback to handle validation errors */
    private final Function<OptionsParseResult, RuntimeException> onValidationErrors;
    /** SpEL configuration functions */
    private final IConfigurableSpelEvaluator spelEvaluator = SpelEvaluator.JSON_GENERIC.copy().configure(this::configureSpelEvaluator);
    /** Parameter converters as generated by {@link #createDefaultParameterConverters()} amended by 
     *  custom converters as added through the {@link #addParameterConverter(String, BiFunction)} and
     *  {@link #addParameterConverter(String, Function)} methods. */
    private final Map<String, BiFunction<String, ParameterTypeConverterArgs, JsonNode>> parameterConverters = createDefaultParameterConverters();
    /** Request helpers as configured through the {@link #addRequestHelper(String, IActionRequestHelper)} method */
    private final Map<String, IActionRequestHelper> requestHelpers = new HashMap<>();
    
    private final void configureSpelEvaluator(SimpleEvaluationContext context) {
        SpelHelper.registerFunctions(context, ActionSpelFunctions.class);
        context.setVariable("action", new ActionUtil());
    }
    
    @Reflectable
    private final class ActionUtil {
        @SuppressWarnings("unused")
        public final String copyParametersFromGroup(ObjectNode parameters, String group) {
            StringBuilder result = new StringBuilder();
            for ( var p : getAction().getParameters() ) {
                if ( group==null || group.equals(p.getGroup()) ) {
                    var val = parameters.get(p.getName());
                    if ( val!=null && StringUtils.isNotBlank(val.asText()) ) {
                        result
                          .append("\"--")
                          .append(p.getName())
                          .append("=")
                          .append(val.asText())
                          .append("\" ");
                    }
                }
            }
            return result.toString();
        }
    }
    
    public final ActionRunnerConfig addParameterConverter(String type, BiFunction<String, ParameterTypeConverterArgs, JsonNode> converter) {
        getParameterConverters().put(type, converter);
        return this;
    }
    public final ActionRunnerConfig addParameterConverter(String type, Function<String, JsonNode> converter) {
        getParameterConverters().put(type, (v,a)->converter.apply(v));
        return this;
    }
    public final ActionRunnerConfig addRequestHelper(String name, IActionRequestHelper requestHelper) {
        getRequestHelpers().put(name, requestHelper);
        return this;
    }
    
    public final IActionRequestHelper getRequestHelper(String name) {
        if ( StringUtils.isBlank(name) ) {
            if ( getRequestHelpers().size()==1 ) {
                return getRequestHelpers().values().iterator().next();
            } else {
                throw new IllegalStateException(String.format("Required 'from:' property (allowed values: %s) missing", getRequestHelpers().keySet()));
            }
        } 
        var result = getRequestHelpers().get(name);
        if ( result==null ) {
            throw new IllegalStateException(String.format("Invalid 'from: %s', allowed values: %s", name, getRequestHelpers().keySet()));
        }
        return result;
    }
    
    @Builder @Data
    public static final class ParameterTypeConverterArgs {
        private final IProgressWriterI18n progressWriter;
        private final ISpelEvaluator spelEvaluator;
        private final Action action;
        private final ActionParameter parameter;
        private final ObjectNode parameters;
    }
    
    private static final Map<String, BiFunction<String, ParameterTypeConverterArgs, JsonNode>> createDefaultParameterConverters() {
        Map<String, BiFunction<String, ParameterTypeConverterArgs, JsonNode>> result = new HashMap<>();
        // TODO Most of these will likely fail in case value is null or empty
        result.put("string",  (v,a)->new TextNode(v));
        result.put("boolean", (v,a)->BooleanNode.valueOf(Boolean.parseBoolean(v)));
        result.put("int",     (v,a)->IntNode.valueOf(Integer.parseInt(v)));
        result.put("long",    (v,a)->LongNode.valueOf(Long.parseLong(v)));
        result.put("double",  (v,a)->DoubleNode.valueOf(Double.parseDouble(v)));
        result.put("float",   (v,a)->FloatNode.valueOf(Float.parseFloat(v)));
        result.put("array",   (v,a)->StringUtils.isBlank(v)
                ? JsonHelper.toArrayNode(new String[] {}) 
                : JsonHelper.toArrayNode(v.split(",")));
        // TODO Add BigIntegerNode/DecimalNode/ShortNode support?
        // TODO Add array support?
        return result;
    }
}
