# Make sure none of the commands inherit usage header or description of the top-level fcli command
# Note that we define these as usage.* whereas our parent bundle defines fcli.usage.* (with fcli prefix).
# For some reason, overriding fcli.usage.* doesn't work.
usage.header = 
usage.description = 

# fcli util
# TODO Provide more details in usage description, after deciding whether the license-related
# commands should stay in this module, or moved to a new, separate module.
fcli.util.usage.header = Utility commands that don't fit in any of the other modules.
fcli.util.usage.description = This module provides various utility commands that don't fit in any of the other fcli modules. 

# fcli util all-commands
fcli.util.all-commands.usage.header = List and display help information for all fcli commands.
fcli.util.all-commands.list.usage.header = List (a subset of) all fcli commands.
fcli.util.all-commands.list.usage.description = By default, this command outputs a table listing all available fcli commands. The --query option can be used to output a subset of commands.
fcli.util.all-commands.list.query.0 = Only display records for which the given Spring Expression Language (SpEL) expression returns true. See the output of '-o json-properties' for the list of properties that you can query on. Common queries include the following:
fcli.util.all-commands.list.query.1 = -q '!hidden' (only non-hidden commands)
fcli.util.all-commands.list.query.2 = -q 'hidden' (only hidden commands)
fcli.util.all-commands.list.query.3 = -q '!runnable' (only container commands)
fcli.util.all-commands.list.query.4 = -q 'runnable' (only runnable commands)
fcli.util.all-commands.list.query.5 = -q '!hidden && runnable' (only non-hidden, runnable commands)
fcli.util.all-commands.list.query.6 = -q 'module=="config"' (only 'config' commands)
fcli.util.all-commands.usage.usage.header = Display usage information for (a subset of) all fcli commands.
fcli.util.all-commands.usage.usage.description = By default, this command outputs the usage information for every individual fcli command, similar to manually invoking each command with the --help option. The --query option can be used to only display usage information for a subset of commands.
fcli.util.all-commands.usage.query.0 = Only display usage information for commands that match the given Spring Expression Language (SpEL) expression. See the output of 'fcli util all-commands list -o json-properties' for the list of properties that you can query on. Common queries include the following: 
fcli.util.all-commands.usage.query.1 = -q '!hidden' (only non-hidden commands)
fcli.util.all-commands.usage.query.2 = -q 'hidden' (only hidden commands)
fcli.util.all-commands.usage.query.3 = -q '!runnable' (only container commands)
fcli.util.all-commands.usage.query.4 = -q 'runnable' (only runnable commands)
fcli.util.all-commands.usage.query.5 = -q '!hidden && runnable' (only non-hidden, runnable commands)
fcli.util.all-commands.usage.query.6 = -q 'module=="config"' (only 'config' commands) 

# fcli util auto-complete
fcli.util.auto-complete.usage.header = Manage fcli auto-completion scripts.
fcli.util.auto-complete.generate.usage.header = Generate fcli auto-completion script.
fcli.util.auto-complete.generate.usage.description.0 = Generate bash/zsh completion script for ${ROOT-COMMAND-NAME:-the root command of this command}. 
fcli.util.auto-complete.generate.usage.description.1 = Run the following command to give `${ROOT-COMMAND-NAME:-$PARENTCOMMAND}` TAB completion in the current shell:
fcli.util.auto-complete.generate.usage.description.2 = \u0020\u0020source <(${PARENT-COMMAND-FULL-NAME:-$PARENTCOMMAND} ${COMMAND-NAME})

# fcli util crypto
fcli.util.crypto.usage.header = Encrypt and decrypt data.
fcli.util.crypto.usage.description.0 = These commands allow for encrypting and decrypting string values using fcli built-in encryption mechanism and password. The password can be customized through the FCLI_ENCRYPT_KEY environment variable, obviously the same password should be configured during encryption and decryption.
fcli.util.crypto.usage.description.1 = Note that for now, encryption and decryption is not compatible with Fortify's pwtool utility. These commands are mainly meant to allow encrypted passwords to be stored in fcli configuration files, for example as used by the 'fcli license msp-report' and 'fcli license ncd-report' commands.
fcli.util.crypto.encrypt.usage.header = Encrypt a value.
fcli.util.crypto.encrypt.prompt = Value to encrypt:
fcli.util.crypto.decrypt.usage.header = Decrypt a value.
fcli.util.crypto.decrypt.prompt = Value to decrypt:

# fcli util mcp-server
fcli.util.mcp-server.usage.header = (PREVIEW) Manage fcli MCP server for LLM integration
fcli.util.mcp-server.start.usage.header = (PREVIEW) Start fcli MCP server for LLM integration
fcli.util.mcp-server.start.usage.description.0 = This command will start an MCP (Model Context Protocol) server \
  that allows an LLM system to interact with Fortify products by executing fcli commands. For more information \
  about MCP, please see https://modelcontextprotocol.io/.\
  %n%n\
  For now, only local stdio transport is supported. MCP server configuration may vary across IDEs and other \
  LLM clients; the following snippet shows how to configure two MCP servers covering respectively 'fcli ssc' and \
  'fcli sc-sast' commands in IDEs like Visual Studio Code or Eclipse: \
  %n\
  %n{\
  %n  "servers": {\
  %n    "fcli-ssc": {\
  %n      "type": "stdio",\
  %n      "command": "/path/to/fcli",\
  %n      "args": ["util","mcp-server","start","--module=ssc"]\
  %n    },\
  %n    "fcli-sc-sast": {\
  %n      "type": "stdio",\
  %n      "command": "/path/to/fcli",\
  %n      "args": ["util","mcp-server","start","--module=sc-sast"]\
  %n    }\
  %n  }\
  %n}\
  %n%n\
  By default, the fcli MCP server will generate an MCP tool definition for every individual fcli command in the specified \
  module, excluding:%n\
  %n- Non-runnable (container) commands, as these are not relevant in LLM context \
  %n- Potentially disruptive or destructive commands like (most) update, delete, clear, and purge commands \
  %n- Any command that requires sensitive data like credentials to be specified, to avoid users from entering their sensitive data in an LLM system \
  %n%n\
  Note that the latter means that LLMs cannot run fcli session login commands; you'll need to have one or more active \
  sessions for each of the products that you want to interact with through the LLM. In your LLM chat, you can ask for a \
  specific session to be used for executing a given operation. %n\
  %n\
  For now, only commands from product-related fcli modules like 'fod' or 'ssc' can be exposed as MCP tools. If you \
  require any of the other fcli modules like 'fcli tool' or 'fcli util' to be exposed as MCP tools, we can consider \
  this for a future release.%n\
  %n\
  As LLMs pose limits on the number of enabled tools, and clients often allow for easily enabling or disabling all \
  tools provided by a given MCP server, each fcli MCP server instance only supports a single fcli module. For example, \
  you can configure separate MCP servers for ssc, sc-sast, and sc-dast modules, but keep the sc-dast MCP tools disabled \
  until you need them.%n\
  %n\
  In a future fcli version, we plan on adding support for registering fcli actions as MCP tools, as well as adding new \
  fcli actions for running various tpes of scans. For example, once we've introduced a sast-scan or debricked-scan action, \
  LLMs would then be able to simply invoke a single MCP tool to run such a scan, with the fcli action taking care of \
  combining commands for installing and running tools, submitting scan requests, and optionally waiting for scan completion \
  and importing results into SSC.  
fcli.util.mcp-server.start.module = Fcli module to expose through this MCP server instance.

# fcli util sample-data
fcli.util.sample-data.usage.header = (INTERNAL) Generate sample data
fcli.util.sample-data.usage.description = These commands generate and output a fixed set of sample data \
  to allow for demonstrating and testing generic fcli functionality like the various output and query options. \
  The output is guaranteed to be the same on each invocation for a given fcli version, but output may vary \
  between different fcli versions.        
fcli.util.sample-data.list.usage.header = (INTERNAL) Generate a list of sample data records
fcli.util.sample-data.list.usage.description = This commands generates a fixed set of sample data \
  to allow for demonstrating and testing generic fcli functionality like the various output and query options. \
  The output is guaranteed to be the same on each invocation for a given fcli version, but output may vary \
  between different fcli versions.
fcli.util.sample-data.get.usage.header = (INTERNAL) Retrieve a single sample data record
fcli.util.sample-data.list.usage.description = This commands retrieves a single record from the fixed set of \
  sample data to allow for demonstrating and testing generic fcli functionality like the various output options. \
  The output is guaranteed to be the same on each invocation for a given fcli version and a given record id, but \
  output may vary between different fcli versions.   
fcli.util.sample-data.id = Sample data record id

# fcli util state
fcli.util.state.usage.header = Manage fcli state data.
fcli.util.state.usage.description = The commands in this module allow for managing fcli state, like clearing all state data. 
fcli.util.state.clear.usage.header = Clear all fcli state data.
fcli.util.state.clear.usage.description = This command deletes all state data from the fcli data directory. This includes variable data and session data. As a best practice, you should log out of existing sessions before running this command to perform proper session cleanup. This command does not clear fcli configuration data; please use the 'fcli config clear' command for clearing configuration data. 
fcli.util.state.clear.confirm = Confirm deleting all fcli state.

# fcli util variable
fcli.util.variable.usage.header = Manage fcli variables.
fcli.util.variable.clear.usage.header = Clear all fcli variables.
fcli.util.variable.delete.usage.header = Delete a single fcli variable.
fcli.util.variable.get.usage.header = Get fcli variable meta-data.
fcli.util.variable.list.usage.header = List fcli variables.
fcli.util.variable.contents.usage.header = Get fcli variable contents.
fcli.util.variable.name = Variable name.

#################################################################################################################
# The following are technical properties that shouldn't be internationalized ####################################
#################################################################################################################
fcli.util.all-commands.list.output.table.args = command,hidden,runnable,usageHeader
fcli.util.state.clear.output.table.args = name,type
# Empty on purpose; output columns depend on variable contents, so we don't want default variable columns
fcli.util.variable.contents.output.table.args = 
fcli.util.variable.output.table.args = created,accessed,name,defaultPropertyName,singular,encrypted
fcli.util.github.list-releases.output.table.args = tag_name,prerelease,html_url
fcli.util.github.list-release-assets.output.table.args = release.tag_name,release.prerelease,browser_download_url,digest_algorithm,digest
fcli.util.sample-data.output.table.args = id,stringValue,longValue,doubleValue,booleanValue,dateValue,dateTimeValue,nestedObject?.stringValue,nestedObject?.booleanValue,nestedStringArray

