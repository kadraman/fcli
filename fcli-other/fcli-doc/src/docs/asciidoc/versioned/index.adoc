= Fortify CLI (fcli) Installation & Usage

== Introduction

The fcli utility can be used to interact with various Fortify products, like Fortify on Demand (FoD), Software Security Center (SSC), ScanCentral SAST and ScanCentral DAST. This document describes installation and general usage of fcli. For a full listing of fcli commands and corresponding command line options, please see the man-pages as listed in the link:#_manual_pages[Manual Pages] section.

Some of the fcli highlights:

* Interact with many different Fortify products with just a single command-line utility
* link:#_installation[Both plain Java and native platform binaries for Windows&#44; Linux and Mac available]
* link:#_command_structure[Modular command structure], making it easy to focus on particular tasks
* link:#_o_output[Rich output formats]; save command output in JSON, CSV, XML or plain-text formats
* link:#_session_management[Session-based]; no need to pass URL’s and credentials on every individual fcli invocation
* Support for configuring option values through link:#_environment_variables[environment variables]
* Support for link:#_fcli_variables[fcli variables]; pass data between fcli commands
* Support for installing other Fortify-related tools
* Support for running multi-purpose YAML-based link:#_actions[actions]

The following Fortify products are currently supported by fcli:

* Software Security Center (SSC)
** Includes virtually all functionality provided by the legacy FortifyClient utility
** Includes virtually all functionality provided by the ssc-client sample shipped with SSC
** Adds a wide range of other functionalities not previously included in any Fortify client-side utilities
* ScanCentral SAST
** Support for starting and managing ScanCentral SAST scans
* ScanCentral DAST
** Support for starting and managing ScanCentral DAST scans
** Support for listing scan policies and settings
** Support for listing and managing sensors
* Fortify on Demand (FoD)
** Support for creating and managing applications, microservices and releases
** Support for starting and managing SAST & OSS scans
** Support for importing/downloading SAST/DAST/MAST & OSS results
** Partial/preview support for starting and managing DAST & MAST scans
** Partial/preview support for managing users, groups and their assignments

Some commands and options are either hidden or marked as `PREVIEW` or `LEGACY`; these may change at any time, even between minor fcli versions. Any fcli invocations using these commands or options may break when upgrading to a future fcli 2.x version, so if possible you should refrain from using these in pipelines for example. Most notably, this includes the following functionalities:

* Commands for configuring and running FoD DAST & MAST scans will change significantly, based on upcoming FoD API changes & improvements

Hidden commands are not listed in fcli help output and not included in the link:#_manual_pages[Manual Pages]. If needed, you can view the list of hidden commands using the `+fcli util all-commands list -q hidden+` command.

== Migration from v2.x

Upgrading from fcli v2.x to fcli v3.x may require you to update your workflows and, if applicable, updating any
custom fcli actions. Please see the link:../migration-v2.x-v3.x.html[migration guide] for details.

== Release Assets

Release assets for fcli are available on the https://github.com/fortify/fcli/releases[Releases] page. This page lists both development releases (named `+Development Release - <branch> branch+`) and final releases. In general, the use of a final release is recommended, unless you want to use any functionality that hasn’t made it into a final release yet.

Each release comes with a list of assets:

* `+docs-html.zip+` & `+docs-manpage.zip+`: Manual pages in either HTML or manpage format
* `+fcli-linux.tgz+`, `+fcli-mac.tgz+` & `+fcli-windows.zip+`: Native binaries for each of the mentioned platforms
** Note that some browsers by default will disallow downloading of `+fcli-windows.zip+`; please bypass the warning
** Linux and Mac downloads include an `+auto-completion+` script that makes interactive fcli usage easier
* `+fcli.jar+`: Java version of fcli, which should be runnable on any platform that has Java 17+ installed
** Note that in general, the native binaries are easier to invoke, offer better performance, and have the benefit of auto-completion capabilities on Linux & Mac
** If you experience any unexpected behavior with native binaries, like commands or command line options not being listed or recognized, or technical error messages about methods, constructors or serializers not being
found, please try with the Java version as it may be an issue specific to the native binaries. See the link:#_troubleshooting[Troubleshooting] section for details.
* `+fcli-thirdparty.zip+`: Third-party licenses and sources for license purposes; usually no need to download
* `+LICENSE.TXT+` & `+README.md+`: Some generic information and license for fcli
* `+*.sha256+`: SHA256 checksum for each asset
* `+*.rsa_sha256+`: RSA SHA256 signature for each asset, to be verified using this link:https://raw.githubusercontent.com/fortify/tool-definitions/main/id_rsa.pub[public key]

Please note that when publishing a new release, it may take up to 30-60 minutes before release assets are posted. If the latest release doesn’t show any of the assets listed above, please check again in 30-60 minutes. If you encounter a release without these assets after waiting for 60 minutes, please consider submitting an issue on the https://github.com/fortify/fcli/issues[fcli issue tracker].

== Installation

The instructions in this section are only applicable if you wish to install the native or Java binaries onto your local system. We also provide Docker images for fcli; see https://hub.docker.com/repository/docker/fortifydocker/fcli/general[fortifydocker/fcli] for information on how to run fcli using these Docker images.

To install the fcli executables on your local system, start by visiting the fcli https://github.com/fortify/fcli/releases[Releases] page as described in the previous section, and downloading the `fcli.jar` file or appropriate native binary archive for your platform. Native binary archives will need to be extracted to a temporary directory, the `fcli.jar` file can be used as-is. 

As a best practice, you should verify the integrity of the downloaded file. Release assets include `+*.sha256+` and `+*.rsa_sha256+` for this purpose, with the latter being preferred for better security. For example, after downloading both `+fcli-linux.tgz+` and `+fcli-linux.tgz.rsa_sha256+`, you can verify integrity by running the following OpenSSL command:

----
  openssl dgst -sha256 -verify <(echo "-----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArij9U9yJVNc53oEMFWYp
  NrXUG1UoRZseDh/p34q1uywD70RGKKWZvXIcUAZZwbZtCu4i0UzsrKRJeUwqanbc
  woJvYanp6lc3DccXUN1w1Y0WOHOaBxiiK3B1TtEIH1cK/X+ZzazPG5nX7TSGh8Tp
  /uxQzUFli2mDVLqaP62/fB9uJ2joX9Gtw8sZfuPGNMRoc8IdhjagbFkhFT7WCZnk
  FH/4Co007lmXLAe12lQQqR/pOTeHJv1sfda1xaHtj4/Tcrq04Kx0ZmGAd5D9lA92
  8pdBbzoe/mI5/Sk+nIY3AHkLXB9YAaKJf//Wb1yiP1/hchtVkfXyIaGM+cVyn7AN
  VQIDAQAB
  -----END PUBLIC KEY-----") -signature "fcli-linux.tgz.rsa_sha256" "fcli-linux.tgz"
----

If your shell doesn't support `+<(...)+` syntax, you'll need to save the link:https://raw.githubusercontent.com/fortify/tool-definitions/main/id_rsa.pub[public key] to a file and pass the file name to the `-verify` command line option, for example:

----
  openssl dgst -sha256 -verify pubkey.pem -signature "fcli-linux.tgz.rsa_sha256" "fcli-linux.tgz"
----

Once downloaded, verified and extracted (if applicable), you can either perform a manual or managed installation. Managed installation is recommended, but only available on internet-connected systems. Please see the sections below for more information.

=== Managed Installation

Managed installation is only available on internet-connected systems, or if your company hosts the various Fortify tools (including fcli) internally and provides a corresponding custom tool definitions bundle. Advantages of a managed installation:

* Both fcli and other tools installed using `fcli tool` commands will be hosted under a single base directory
* This base directory will contain a single `bin` directory that can be added to your `PATH` for easy invocation of all tools installed through fcli
* The `fcli tool fcli list` command can be used to list both installed and available fcli versions
* The `fcli tool fcli install` command can be used to easily upgrade the current fcli version

The steps below describe how to perform a managed fcli installation. The syntax for invoking the various commands depends on the fcli variant that you downloaded. If you downloaded `fcli.jar`, fcli can be invoked using `java -jar /path/to/fcli.jar`. If you downloaded a native binary, fcli can be invoked using `/path/to/fcli` (Linux/Mac) or `C:\path\to\fcli.exe` (Windows). Any use of `fcli` in the commands below should be replaced by the appropriate command for invoking fcli on your system.

* If necessary, configure fcli proxy settings:
** View usage information: +
   `fcli config proxy add -h`
** Configure proxy settings: +
   `fcli config proxy add [options]`
** For example: +
   `fcli config proxy add myproxy:8080 -u<proxy user> -p<proxy password>`
* Update tool definitions to make fcli aware of latest tool releases:
** View usage information: +
   `fcli tool definitions update -h`
** Update with default Fortify tool definitions: +
   `fcli tool definitions update`
** Update with company-provided tool definitions: +
   `fcli tool definitions update --source <tool-definitions-source>`
* Install the latest available fcli version:
** View usage information: +
   `fcli tool fcli install -h`
** View available fcli versions: +
   `fcli tool fcli list`
** Install the latest available fcli version to the default base directory: +
   `fcli tool fcli install -v latest`
* Add the global Fortify tools `bin` directory to your PATH environment variable, for example in the Windows User or System Environment variables, or in your `.bashrc` or `.profile` file.
** Unless `--base-dir` is specified on the `fcli tool fcli install` command, the Fortify tools global `bin` directory defaults to `<user.home>/fortify/tools/bin`.
* Linux/Mac only: Run the following command to install fcli auto command completion, allowing for use of the `+<tab>+` key to get suggestions for fcli command and option names. You may want to add this to your shell startup script like `.bashrc`, such that fcli auto-completion is readily available in every shell. +
`+source <user.home>/fortify/tools/bin/fcli_completion+` +

=== Manual Installation

* Copy the `fcli.jar` file or the extracted native binaries to a directory of your choosing.
* If using `fcli.jar`, create a simple wrapper script/batch file that invokes `java -jar /path/to/fcli.jar`, passing all the script arguments to this Java command.
* For ease of use, add the directory to your operating system or shell PATH environment variable, or move `+fcli+`/`+fcli.exe+`/wrapper script to a directory that is already on the PATH
* Linux/Mac only: Run the following command to install fcli auto command completion, allowing for use of the `+<tab>+` to get suggestions for fcli command and option names. You may want to add this to your shell startup script, such that fcli auto-completion is readily available in every shell. +
`+source <extraction-dir>/fcli_completion+`

== Upgrade

If you prefer a manual installation/upgrade, you can download the latest fcli version for your platform from the fcli https://github.com/fortify/fcli/releases[Releases] page and follow the link:#_manual_installation[Manual Installation] instructions above, adjusting any manually created wrapper scripts to point to the new installation.

However, on internet-connected systems, or if your company hosts the various Fortify tools (including fcli) internally and provides a corresponding custom tool definitions bundle, the preferred upgrade approach is through the use of fcli commands as described below.

Notes:

* These steps assume that all other steps from the link:#_managed_installation[Managed Installation] instructions have already been performed during initial installation, like configuring a proxy server if applicable, and adding the global `bin` directory to your `PATH`.
* If the requested version has already been installed, it will be used as-is; only post-installation tasks like replacing the global bin-script(s) will be performed.
* Similar steps apply for upgrading any of the Fortify-related tools installed through the various `fcli tool * install` commands.

Upgrade steps:

* Update tool definitions to make fcli aware of latest tool releases:
** Update with default Fortify tool definitions: +
   `fcli tool definitions update`
** Update with company-provided tool definitions: +
   `fcli tool definitions update --source <tool-definitions-source>`
* Upgrade fcli
** Install latest version, removing all previous (managed) fcli installations: +
   `fcli tool fcli install -v latest --uninstall all`
** Install latest 2.x.y version, removing all previous 2.x.y installations but keeping any 1.x.y installations: +
   `fcli tool fcli install -v 2 --uninstall 2`
* Re-source the `fcli_completion` script if applicable on your platform

== Command Structure

Fcli provides a product-oriented command structure, with each product represented by a separate tree of subcommands. For example, the `+fcli fod+` command tree can be used to interact with Fortify on Demand
(FoD), and the `+fcli ssc+` command tree can be used to interact with Fortify Software Security Center (SSC). There are also some non product-related command trees, like the `+fcli config+` command tree to manage fcli configuration.

To see what top-level fcli commands are available, you can use the `+fcli --help+` command. You can drill down into the command tree to see what sub-commands are available within a particular parent command, for example by running `+fcli ssc --help+` to see all `+fcli ssc+` sub-commands, or `+fcli ssc session --help+` to see all SSC session management commands. 

Note that the `--help` option must be specified _after_ the sub-command for which you want view usage instructions, i.e. `+fcli ssc --help+` and _not_ `+fcli --help ssc+`. A listing of all available fcli commands can be viewed using the `+fcli util all-commands list+` command.

If you don’t have fcli up and running yet, you can also refer to the downloadable or online manual pages; refer to the link:#_manual_pages[Manual Pages] section for more information.

== Common Options

The following sections describe common options that are available on (most) fcli commands.

=== -h | --help

This option can be used on every fcli (sub-)command to view usage information for that command. Usage information usually shows the command synopsis, a description of the functionality provided by the command, and a description of each command line option or parameter accepted by the command.

=== --env-prefix

As described in the link:#_environment_variables[Environment Variables] section, default option and parameter values can be retrieved from environment variables starting with `+FCLI_DEFAULT+`. This option allows for configuring a different environment variable prefix. This may be useful if, for example, you want to login to multiple instances of the same system using environment variables. For example, when running `+fcli ssc session login --env-prefix PROD+`, fcli will look for environment variables like `+PROD_SSC_URL+` instead of `+FCLI_DEFAULT_SSC_URL+`.

Note that a default value for the `+--env-prefix+` option itself can be specified through an `+FCLI_DEFAULT_ENV_PREFIX+` environment variable, for example if you want to globally override the `+FCLI_DEFAULT+` prefix.

=== --log-file

This option can be used on every fcli (sub-)command to specify the file to which to output log data. If not specified, currently no log data will be written, although future versions may specify a default log file
location in the fcli data folder.

=== --log-level

This option can be used on every fcli (sub-)command to specify the fcli log level; see the help output for a list of allowed levels. Note that this option also requires the `+--log-file+` option to be specified,
otherwise no log will be written.

=== --log-mask

Masking level to apply to logging data. Allowed values: high, medium, low, none. Default value: medium. Note that this is on a best-effort basis; you should always check log contents for sensitive data before sharing or publishing logs.

=== --debug

Enable both fcli trace logging and collection of extra debugging data on applicable fcli actions and commands, for example enabling debug logging on tools invoked through fcli tool run commands, or enabling server-side debug log generation.

=== -o | --output

Available on virtually all (leaf) commands that output data, this option can be used to specify the output format. Fcli supports a wide variety of output formats, like `+table+`, `+csv+`, `+json+`, `+xml+`, and `+yaml+`, allowing for both human-readable output or output suitable for automations. The style for each of these output formats can be controlled through the `+--style+` option, for example for controlling whether table or CSV output should include headers or not; see next section for details.

The output formats listed above optionally allow for specifying the JSON properties to be included in the output, for example `+-o csv=id,name+`. Optionally, properties can also be renamed, which for example may be used to define CSV or table header names, like `+-o "csv=id:Application Id,name:Application Name"+`. If no JSON properties are specified, most output formats will output all available JSON properties, except for table output, which usually outputs a predefined set of JSON properties.

Apart from the output formats listed above, fcli also supports the special `+expr+` output format that can be used for a variety of purposes, for example for generating output in a human-readable format, or for generating a list of commands to be run at a later stage. This output format takes a template expression as input, for example `+-o 'expr=Text with {expression1} or {expression2}\n'+`. In most cases, expressions will be simple JSON property references, i.e., `+{property.subProperty}+`.

Following are two examples of how `+-o expr+` can be used to generate a script that purges all application versions matching certain criteria:

* `+fcli ssc appversion list -q 'createdBy=="admin"' -o 'expr=fcli ssc appversion purge-artifacts --older-than 30d {id}\n'+`
* `+for id in $(fcli ssc appversion list -q 'createdBy=="admin"' -o 'expr={id} '); do echo "fcli ssc appversion purge-artifacts –older-than 30d ${id}'"; done+`  

Note that all output (for all records being processed) will be appended on a single line, unless the expression explicitly includes `+\n+` to output a newline character; notice the `+\n+` in the first example above to print each generated fcli command on a separate line, and the trailing space in the second example to list all id's on a single line but separated by a space. Also note that depending on your shell, the `+expr+` option must be properly quoted. For most shells, the `+expr=...+` value should be enclosed in single or double quotes. 

=== --style

The `--style=<style element>[,<style element>...]` option can be used to control the output style for most of the output formats listed above, for example to control whether CSV or table headers should be included or not, or whether JSON or YAML output should be flattened. Note that the `--style` option will be ignored for the `expr` output format, and similarly, any style elements that are not applicable for the output format specified in the `-o` option will be ignored. Multiple style elements can be specified by separating them by comma's.

Some examples:

* Output a table with border and no headers: `-o table --style no-header,border`
* Output non-pretty flattened JSON: `-o json --style no-pretty,flat`

A full list of style elements that can be applied to the output is available in fcli help output or manual pages; the following table lists the most commonly used style elements:

[cols="1,2,3"]
|===
|Style&nbsp;Element|Applies&nbsp;To|Description

|`+header+` +
`+no-header+`
|`+csv+` +
`+table+`
|By default, these output formats include headers; use the `no-header` style element to output table or CSV without headers.

|`+border+` +
`+md-border+` +
`+no-border+`
|`+table+`
|By default, tables are printed without borders; use `border` to output a table with borders, or `md-border` to output a table with Markdown borders. Note that `md-border` is only meant for outputting simple, short property values. The output will not be a valid Markdown table if any of the output properties contains pipe or newline characters, or if contents are too long to be printed on a single line.

|`+pretty+` +
`+no-pretty+`
| `+json+` +
`+yaml+` +
`+xml+`
|By default, these output formats are pretty-printed; use the `no-pretty` style element to output condensed, non-pretty output.

|`+flat+` +
`+no-flat+`
| `+json+` +
`+yaml+` +
`+xml+`
|By default, these output formats will keep nested objects and arrays as returned by (for example) the server; use the `flat` style element to flatten any nested structures into top-level properties.

|`+array+` +
`+single+`
| `+json+` +
`+yaml+`
|Whether the output will be represented as an array or single object depends on the fcli command being run, for example `list` commands will output arrays, and `get` commands will output a single object. For commands that output a single object, you can use the `array` style element to output a single-element array instead of a single object. Using `single` on commands that output multiple records is not supported; this may lead to exceptions or unparsable output.
|===

=== --store

Available on virtually all (leaf) commands that output data, this option can be used to store command output data in an fcli variable. For more details, see the link:#_fcli_variables[Fcli Variables] section.

=== --to-file

Write command output in the format as specified through the `+--output+` option to the given file. Compared to using redirection, any status messages will still appear on the console rather than being included in the output file.

=== --progress

Various commands offer a `+--progress+` option to specify how to output progress messages. This option supports the following values:

* `+auto+`: Automatically select between `+ansi+`, `+single-line+` and `+simple+` depending on console capabilities.
* `+none+`: Don't output any progress messages.
* `+simple+`: Output every progress message on a separate line, effectively leaving older progress messages visible. This will be used by default if no console is available, for example during pipeline runs. Supports multi-line progress messages.
* `+single-line+`: Uses the `+\r+` (carriage return) character to overwrite previous progress message. This will be used by default if a non-ANSI console is detected. Supports single-line progress messages only.
* `+ansi+`: Uses ANSI escape sequences to overwrite previous progress messages. This will be used by default if ANSI capabilities are detected. Supports multi-line progress messages.

=== -q | --query

Available on most `+list+` commands and some other commands, this option allows for querying the output data, outputting only records that match the given Spring Expression Language (SpEL) expression. See the link:#_option_expressions[Option Expressions] section for details.

Expressions are evaluated on individual records; record properties can be accessed as shown in the SpEL documentation. The list of properties that can be queried can be obtained by executing the current command with the `+-o json-properties+` option; see link:++#-o--output++[-o | –output] for details.

Following are some examples using bash syntax, assuming the record contains `p1`, `p2`, ... properties:

* `+-q 'p1=="v1"'+` +
  Only output records if the value of property `p1` equals `v1`
* `+-q 'p1=="v1" || p1=="v2"'+` +
  Only output records if the value of property `p1` equals either `v1` or `v2`
* `+-q '{"v1","v2"}.contains(p1)'+` +
  Same as previous, but more concise if matching against many different values
* `+-q 'name matches "val1|val2"'+` +
  Similar as above, but using regex-based OR matching
* `+-q 'p2==25 || p2<5'+` +
  Only output records if the value of property `p2` either equals 25 or is less than 5
* `+-q 'p1=="v1" && (p2=="v2" || p3=="v2")'+` +
  Only output records if the value of property `p1` equals `v1` and the value of either property `p2` or `p3` is `v2`
* `+fcli ssc artifact list --appversion MyApp:main -q 'scanTypes matches "\bSCA\b"'+` +
  Only output artifacts containing a Fortify SCA scan (matching the whole word `SCA` against `scanTypes` property)
* `+fcli ssc artifact list --appversion MyApp:main -q '_embed.scans.![buildLabel].contains("myLabel")'+` +
  Only output artifacts for which any of the scans included in the artifact has a `buildLabel` that equals `myLabel`
* `+fcli ssc artifact list --appversion MyApp:main -q '#now("-90d") < #date(uploadDate)'+` +
  Only output artifacts that were uploaded less than 90 days ago.

==== Server-side queries

In general, queries specified using the `-q` / `--query` option are evaluated on the client. Some commands will analyze the given query and generate corresponding server-side query parameters to minimize the amount of data that needs to be transferred from server to client. Generated queries can be viewed in the log file if `--log-level` is set to `DEBUG` level.

All commands that automatically generate server-side queries also provide a dedicated option for overriding the automatically generated server-side query, for example to further optimize the query or in case the automatically generated query is causing any issues. Following bullet points provide details on server-side queries for the various product modules:

* FoD: +
  All commands that automatically generate server-side queries provide the `--filters-param` option to override the automatically generated query. Server-side queries are automatically generated for the following SpEL expressions:
** `prop1=='value'` (simple equals expressions)
** `prop1=='val1' || prop1=='val2'` (or-expressions on a single property)
** `{'value1','value2'}.contains(prop1)` (or-expression on a single property)
** `prop1 matches 'literalValue1|literalValue2'` (or-expression on a single property)
** `prop1=='value' && prop2 matches 'val1|val2'` (and-expression containing any of the above)

* ScanCentral SAST: +
  No server-side queries are automatically being generated.

* ScanCentral DAST: +
  No server-side queries are automatically being generated. Some commands provide the `--server-query` option to explicitly pass query parameters to the server.

* SSC: +
  All commands that automatically generate server-side queries provide the `--q-param` option to override the automatically generated query. Server-side queries are automatically generated for the following SpEL expressions:
** `prop1=='value'` (simple equals expressions)
** `prop1=='value' && prop2=='val2'` (and-expression containing simple equals expressions)

=== Option Expressions

Various fcli options take either plain expressions, like link:++#-q--query++[-q | --query], or template expressions (plain text combined with expressions embedded between curly braces), like link:++#-o--output++[-o | –output expr=...]. These expressions use Spring Expression Language (SpEL); general information on syntax, supported operators and more can be found in the link:https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/core.html#expressions[SpEL Documentation].

When evaluating expressions, fcli configures SpEL for 'data binding and condition evaluation', meaning that not all SpEL features are available. In particular, query expressions cannot invoke constructors nor static methods, and write access is mostly disabled. Attempts to access non-existing JSON properties will result in an error, which, although uncommon, may be an issue if the server doesn't consistently return all expected properties. You'll need to explicitly check for property existence in such cases, for example:

* Top-level properties: +
  `+fcli ... list -q '(has("property2") && property2=="value2")'+`
* Nested properties: +
  `+fcli ... list -q 'nestedObject!=null && get("nestedObject").has("stringValue") && nestedObject.stringValue=="nestedObjectValue1"'+`
* Nested array properties: +
  `+fcli ... list -q 'nestedObjectArray !=null && !(nestedObjectArray.isEmpty()) && get("nestedObjectArray").get(0).has("stringValue") && nestedObjectArray.get(0).stringValue=="nestedArrayValue1"'+`
* Variable nested array property as command argument: +
  `+fcli ... get ::yourVar::get(0).id+`
* Variable nested array property in query and output expression: +
  `+fcli ssc av ls -q "application.id == #var('yourVar').get(9).id" -o "expr={name} : {#var('yourVar').get(9).name} : {id}\n"+`

Some SpEL operators like `matches` may throw an exception if any of the operands is `null`. For example, the following will result in an error if the `prop1` propery is `null` for any of the records returned by the `list` command: +

* `+fcli ... list -q 'prop1 matches "value1|value2"'+`

Such errors can be avoided using one of the following approaches:

* Rewrite the expression to not use the `matches` operator, for example: +
  `+fcli ... list -q '{"value1","value2"}.contains(prop1)'+`
* Add null-check (include all records for which `prop` is `null`): +
  `+fcli ... list -q 'prop1==null || prop1 matches "value1|value2"'+`
* Add null-check (exclude all records for which `prop` is `null`): +
  `+fcli ... list -q 'prop1!=null && prop1 matches "value1|value2"'+`

Fcli provides some utility functions that may be used in expressions. Note that these functions calls are preceded by a `+#+` character.

* `+#date(string)+`: Convert the given date/time in string format to a proper date/time representation, allowing for date/time-based comparison operations. This can be used on property references or literal strings.
* `+#now()+`: Get the current date/time, allowing for date/time-based comparison operations.
* `+#now(period)+`: Get the current date/time plus or minus the given period. The given period must start with either a `+` or `-`, followed by a number and the time unit. Some examples: `-90d` (now minus 90 days), `+15m` (now plus 15 minutes) and `-90s` (now minus 90 seconds).
* `+#var(name)+`: Get fcli variable contents; variable properties can be accessed as usual, i.e. `+#var("myVar")?.rootProp?.subProp+`.
* `+#env(name)+`: Get the value of an environment variable.

Note that for date comparisons, both sides of the comparison operator need to be explicitly defined as date/time objects. For example:

* Invalid comparison: `+#date(myprop) < '2023-01-01'+`
* Valid comparison: `+#date(myprop) < #date('2023-01-01')+`
* Valid comparison: `+#date(myprop) < #now('-90d')+`

SpEL expressions may contain various characters that will be interpreted by some shells, like the `#` character for calling functions, and either single or double quotes around literal string values. As such, with most shells you should enclose the full expression in single or double quotes, and use the other quotes in the expression, for example:

* `+-q '... "literal SpEL string" ...'+` (single quotes for shell, double quotes for SpEL literals)
* `+-q "... 'literal SpEL string' ..."+` (double quotes for shell, single quotes for SpEL literals)

Which one to choose depends on any other characters appearing in the expression. For example, in `bash` you'd usually use single quotes to have everything in-between passed to fcli as-is, unless you want to use specific shell features inside the expression. Note that you can use the `+#env+` function to retrieve environment variable contents, so you don't need to use shell syntax to insert environment variable contents into expressions.

== Session Management

Most fcli product modules are session-based, meaning that you need to run a `+session login+` command before you can use most of the other commands provided by a product module, and run a `+session logout+` command when finished, for example:

[source,bash]
----
fcli ssc session login --url https://my.ssc.org/ssc --user <user> --password <password>
fcli ssc appversion list
fcli ssc session logout --user <user> --password <password>
----

For interactive use, you can choose to keep the session open until it expires (expiration period depends on target system and login method). For pipeline use or other automation scenarios, it is highly recommended to issue a `+session logout+` command when no further interaction with the target system is required, to allow for any client-side and server-side cleanup to be performed.

For example, upon logging in to SSC with user credentials, fcli will generate a `+AutomationToken+`, which will be invalidated when the `+ssc session logout+` is being run. If you have many (frequently executed) pipelines that interact with SSC, and you don’t run the `+ssc session logout+` command when the pipeline finishes, you risk exhausting SSC’s limit on active tokens. In addition, the `+logout+` commands will perform client-side cleanup, like removing session details like URL and authentication tokens from the client system.

For product modules that support it, like SSC, it is also highly recommended to use token-based authentication rather than username/password-based authentication when incorporating fcli into pipelines or other automation tasks. This will avoid creation of a temporary token as described above, but also allows for better access control based on token permissions. Similarly, for systems that support Personal Access tokens, like FoD, it is highly recommended to utilize a Personal Access Token rather than user password.

Note however that depending on (personal access) token permissions, not all fcli functionality may be available. For example, the commonly used SSC `+CIToken+` may not provide access to all endpoints covered by fcli. To allow fcli to access all SSC endpoints, you may want to use an `+AutomationToken+`, but please note its security implications as documented by SSC. Alternatively, for self-hosted SSC environments, you can also consider defining custom token definitions, but this functionality is not available on Fortify Hosted.

=== Named Sessions

Fcli supports named sessions, allowing you to have multiple open sessions for a single product. When issuing a `+session login+` command, you can optionally provide a session name as in `+fcli ssc session login --ssc-session mySession ...+`, and then use that session in other commands using the `+--ssc-session mySession+` command line option. If no session name is specified, a session named `+default+` will be created/used. Named sessions allow for a variety of use cases, for example:

* Run fcli commands against multiple instances of the same product, like DEV and PROD instances or an on-premise instance and a Fortify Hosted instance, without having to continuously login and logout from one instance to switch to another instance
* Run fcli commands against a single instance of a product, but with alternating credentials, for example with one session providing admin rights and another session providing limited user rights
* Run one session with username/password credentials to allow access to all fcli functionality (based on user permissions), and another session with token-based authentication with access to only a subset of fcli functionality
* Run multiple pipelines or automation scripts simultaneously, each with their own session name, to reduce chances of these pipelines and scripts affecting each other (see link:#_fcli_data_folder[Fcli Data Folder] though for a potentially better solution for this scenario)

Each session-based product module provides a corresponding `--<module>-session` command line option on both the corresponding `fcli <module> session` commands, and all commands that utilize sessions to connect to a remote system.

=== Session Storage

To keep session state between fcli invocations, fcli stores session data like URL and authentication tokens in the link:#_fcli_data_folder[Fcli Data Folder]. To reduce the risk of unauthorized access to this sensitive data, fcli encrypts the session data files. However, this is not bullet-proof, as the default encryption key and algorithm can be easily viewed in fcli source code. As such, it is recommended to ensure file permissions on the fcli data folder are properly configured to disallow access by other users. Being stored in the user’s home directory by default, the correct file permissions should usually already be in place. For enhanced security, you may also consider setting the `+FCLI_ENCRYPT_KEY+` environment variable; see the link:#_fcli_data_folder[Fcli Data Folder] section for details.

== Environment Variables

The sections below describe various environment variables that can be used to control fcli behavior. This includes environment variables for overriding some of the default directories used by fcli to store data, and for setting default values for command-line options.

=== Proxy Settings

Fcli allows for configuring proxy settings through the `fcli config proxy` commands, supporting a variety of configuration options. In many cases, for example when running fcli in CI/CD pipelines, it's more convenient to configure a single proxy server to be used by all fcli commands through environment variables. For this purpose, fcli supports the following environment variables in either upper or lower (but not mixed) case:

* `HTTP_PROXY`: Proxy to use for plain HTTP requests
* `HTTPS_PROXY`: Proxy to use for HTTPS requests
* `ALL_PROXY`: Proxy to use for all types of requests
* `NO_PROXY`: Don't use a proxy server for the hosts listed in this environment variable

Proxy servers can be specified as either `<host>:<port>` or as a URL. Note that proxy settings configured through `fcli config proxy` take precedence over proxy settings configured through environment variables.

=== Trust Store Settings

Fcli allows for configuring trust store settings through the `fcli config truststore` commands, supporting a variety of configuration options. In many cases, for example when running fcli in CI/CD pipelines, it's more convenient to configure the trust store to be used through environment variables. For this purpose, fcli supports the following environment variables:

* `FCLI_TRUSTSTORE`: Absolute path to the trust store file to use
* `FCLI_TRUSTSTORE_TYPE`: Type of the trust store, usually JKS, which is the default type if not specified
* `FCLI_TRUSTSTORE_PWD`: Trust store password

=== Fcli User Home Folder

By default, fcli will use the home directory of the current user for various operations, like storing fcli state and configuration (see next section) or for tool installations (see `fcli tool` manual pages). These locations can be individually overridden through environment variables or command-line options, but in some cases you may want to just specify an alternative 'user home directory' to have all fcli operations use this alternative directory by default, instead of having to override multiple individual directories.

For this purpose, fcli will check for an environment variable named `+FCLI_USER_HOME+`; if defined, the value of this environment variable will be used instead of the actual user home directory for any fcli command that reads or writes data from/to the user home directory. 

Of course, even if this environment variable is set, you can still override individual directories through the applicable environment variables or command-line options. For example, if you set both `+FCLI_USER_HOME+` and `+FCLI_CONFIG_DIR+` (but not any of the other environment variables listed in the next section), then fcli configuration data will be stored in the directory specified through `+FCLI_CONFIG_DIR+`, whereas fcli state data will be stored in the default directory under `+<FCLI_USER_HOME>+`.

=== Fcli Data Storage

By default, fcli stores configuration and state data like session files (see link:#_session_management[Session Management]), fcli variable contents (see link:#_fcli_variables[Fcli Variables]) and proxy settings in its data folder. Future versions of fcli may also automatically generated log files in this data directory, if no `+--log-file+` option is provided.

The locations of these files can be controlled through the following environment variables:

* `+FCLI_STATE_DIR+`: Location of fcli state like session and variable data. +
  Default: `+<FCLI_DATA_DIR>/state+`
* `+FCLI_CONFIG_DIR+`: Location of fcli configuration data like proxy and trust store settings. +
  Default: `+<FCLI_DATA_DIR>/config+`
* `+FCLI_DATA_DIR+`: Default base directory for the two directories listed above. +
  Default: `+<FORTIFY_DATA_DIR>/fcli/v3+`
* `+FORTIFY_DATA_DIR+`: Default base directory for the directories listed above. +
  Default: `+<user home directory>/.fortify+`

If none of these environment variables have been set, then state data will be stored in `+<user home directory>/.fortify/fcli/v3/state+`, and configuration data will be stored in `+<user home directory>/.fortify/fcli/v3/config+`.

Note: earlier versions of fcli used different environment variable names, but this was causing issues (see link:https://github.com/fortify/fcli/issues/248[Issue 248]). If you are using an older fcli version, please refer to the corresponding documentation. When upgrading fcli from an older version, you may need to adjust the environment variable names.

When utilizing fcli in pipelines or automation scripts, especially when multiple pipelines or scripts may be running simultaneously on a single, non-containerized system, it is highly recommended to have each pipeline use a separate fcli state directory, to avoid those pipelines from sharing session data, variables and other persistent fcli state data. This will avoid issues like different pipelines overwriting each others session data (for example with different URLs or credentials), or one pipeline logging out of a session while another pipeline is still using the session.

Depending on the situation, pipelines can either share fcli configuration data, or be configured to have different configuration data directories. When sharing the configuration data, it is recommended that these pipelines do not update any configuration data during pipeline execution, but rather use pre-configured settings. For example, you could pre-configure fcli with proxy and trust store settings.

On containerized systems, like pipelines running in GitLab or GitHub, the default folders will usually be stored inside the individual pipeline containers and thus will not interfere with each others state.

Note that some files stored in the fcli data directory may contain sensitive data, like authentication tokens generated by login commands, or proxy credentials configured through the `+fcli config proxy+` commands. Fcli encrypts any sensitive files, but since the encryption key and algorithm are hardcoded, these files can be decrypted fairly easily. You should ensure proper file access permissions on the fcli data folder. In addition, you can consider setting the `+FCLI_ENCRYPT_KEY+` environment variable to configure an alternative encryption key. That way, the sensitive files can only be decrypted if someone has access to this custom encryption key.

=== Default Values for CLI options

Apart from the special-purpose environment variables described in the sections above, fcli allows for specifying default option and parameter values through environment variables. This is particularly useful for specifying product URL’s and credentials through pipeline secrets, but also allows for preventing having to manually supply command line options if you frequently invoke a particular command with the same option value(s). For example, you could define a default value for `+--issue-template+` option of the `+fcli ssc appversion create` option, to avoid having to remember the issue template name every time you invoke this command.

Fcli walks the command tree to find an environment variable that matches a particular option, starting with the most detailed command prefix first. For the issue-template example above, fcli would look for the following environment variable names, in this order:

* `+FCLI_DEFAULT_SSC_APPVERSION_CREATE_ISSUE_TEMPLATE+`
* `+FCLI_DEFAULT_SSC_APPVERSION_ISSUE_TEMPLATE+`
* `+FCLI_DEFAULT_SSC_ISSUE_TEMPLATE+`
* `+FCLI_DEFAULT_ISSUE_TEMPLATE+`

Environment variable lookups are based on the following rules:

* Command aliases are not taken into account when looking for environment variables; suppose we have a `+delete+` command with alias `+rm+`, you will need to use `+FCLI_DEFAULT_..._DELETE_...+` and not `+FCLI_DEFAULT_..._RM_...+`
* For options, fcli will use the longest option name when looking for environment variables; suppose we have an option with names `+-a+`, `+--ab+` and `+--abc+`, you will need to use `+FCLI_DEFAULT_..._ABC+` and not `+FCLI_DEFAULT_..._AB+` or `+FCLI_DEFAULT_..._A+`
* For positional parameters, the environment variable name will be based on the parameter label, converted to `SNAKE_CASE` with all special characters replaced by an underscore. For example, `<attributeDefinitionId>` will become `ATTRIBUTE_DEFINITION_ID`, and `HOST:PORT` will become `HOST_PORT`.

Although powerful, these environment variables for providing default option and parameter values should be used with some care to avoid unexpected results:

1. Obviously command option requirements should be respected; supplying default values for exclusive options may result in errors or unexpected behavior
2. Preferably, you should use the most specific environment variable name, like `+FCLI_DEFAULT_SSC_APPVERSION_CREATE_ISSUE_TEMPLATE+` from the example above, to avoid accidentally supplying default values to a similarly named option on other commands

Despite #2 above, in some cases it may be useful to use less specific environment names, in particular if the same default values should be applied to multiple commands. As an example, consider an environment variable named `+FCLI_DEFAULT_SSC_URL+`:

* This variable value will be used as a default value for all `+--url+` options in the SSC module
* This variable value will be used as a default value for all `+--ssc-url+` options in other product modules

Note that as described in the link:#_env_prefix[–env-prefix] section, you can override the `+FCLI_DEFAULT+` prefix. For example, with `+--env-prefix MYPREFIX+`, fcli will look for `+MYPREFIX_*+` environment variables instead of `+FCLI_DEFAULT_*+` environment variables.

== Fcli Variables

Fcli allows for storing fcli output data in fcli variables for use by subsequent fcli commands. This is a powerful feature that prevents users from having to use shell features to parse fcli output when needing to provide output from one command as input to another command. For example, this feature allows for starting a scan, and then passing the scan id to a corresponding `+wait-for+` command, or for creating an SSC application version, and passing the SSC application version id to the `+artifact upload+` command.

Variables can be stored using the `+--store myVarName[:prop1,prop2]+` option on data output commands. If property names are specified, then only these property names will be stored. If no property names are provided, all available JSON properties will be stored.

Variables can be referenced in subsequent fcli commands using the `::myVarName::prop` syntax anywhere on the command line; such occurrences will be substituted with the value of the given property name. Note that such variable references will only be resolved when appearing as a separate command line argument. For example, `--my-opt ::myVarName::prop` will pass the contents of the `prop` property of `myVarName` as the value for `--my-opt`, but `--my-opt=::myVarName::prop` will pass the literal text `::myVarName::prop` as the value for `--my-opt`.

Many (but not all) fcli commands will also store an entity-specific default property name when using the `+--store+` option. Whether a default property name has been stored can be seen in the output of the `+fcli util variable list+` command. If a default property name was stored, the `::myVarName::` syntax can be used to reference the value of the default property name, thereby avoiding the need to manually specify the appropriate property name.

Following are some examples, assuming the necessary login sessions are available:

[source,bash]
----
fcli ssc appversion create myApp:1.0 --auto-required-attrs --skip-if-exists --store myVersion
fcli ssc artifact upload myScan.fpr --appversion ::myVersion::

fcli ssc appversion create myApp:1.0 --auto-required --skip-if-exists --store myVersion:id,name
fcli ssc artifact upload myScan.fpr --appversion ::myVersion::id

fcli sc-sast scan start -f package.zip --publish-to test:1.0 --store x
fcli sc-sast scan wait-for ::x::

fcli sc-sast scan start -f package.zip --publish-to test:1.0 --store x
fcli sc-sast scan wait-for ::x::jobToken
----

Fcli provides the regular `get`, `list` and `delete` operations on the `+fcli util variable+` command tree, and actual variable contents can be retrieved using the `+fcli util variable contents+` command. Please see help output or manual pages for more information on these commands.

The `+fcli util variable contents+` command supports the regular fcli output options and query capabilities. This allows for advanced us cases, like retrieving server data once and then outputting it in multiple formats, potentially even applying separate filters. As an example:

[source,bash]
----
fcli ssc appversion list --store myVersions
fcli util variable contents myVersions -o csv --output-to-file myVersions.csv
fcli util variable contents myVersions -o json -q createdBy=admin --output-to-file myAdminVersions.json
fcli util variable contents myVersions -o 'expr={id}\n' --output-to-file myVersionIds.txt
----

Note: variable-related syntax and behavior was changed in fcli version 2.0.0. If you are using an older fcli version, please refer to the documentation for that version. When upgrading from 1.x.x to 2.x.x or 3.x.x, you may need to update your fcli invocations to match the new syntax. See link:https://github.com/fortify/fcli/issues/160[Issue 160] for information on why syntax and behavior was changed.

== Actions

Fcli actions are a powerful feature that allows for rich integration and automation by running a customizable set of instructions defined in YAML files. These instructions allow for processing data collected from Fortify or third-party products, updating data in those products, and writing output to files or console. 

=== Built-in Actions

Fci comes with various built-in actions, currently focused on providing the following functionality:

* Running a full scan pipeline initiated from various CI/CD systems.
* Vulnerability export to various third-party formats like SARIF or GitHub, GitLab, BitBucket, and SonarQube reports, as a replacement for link:https://github.com/fortify/FortifyVulnerabilityExporter[FortifyVulnerabilityExporter].
* Generating GitHub Pull Request comments, listing (re-)introduced and removed vulnerabilities.
* Generating application version/release summaries in Markdown format, for example for use as pipeline summaries.
* Evaluating security policy criteria, for example allowing to break a build if one or more checks are failing.

Documentation for built-in actions can be found here:

* link:generic-actions.html[Documentation for `fcli action` built-in actions]
* link:fod-actions.html[Documentation for `fcli fod action` built-in actions]
* link:ssc-actions.html[Documentation for `fcli ssc action` built-in actions]

Future fcli versions may introduce new built-in actions, enhance existing built-in actions, or provide enhanced action syntax, for example to allow for running pipeline-style actions that run a set of commands to package source code, submit a scan request, wait for scan completion, and perform post-scan activities like data export or policy checks.

Fcli provides product-agnostic or cross-product actions through the `fcli action *` commands, and FoD & SSC-specific actions through respectively `fcli fod action *` and `fcli ssc action *` commands. Based on user feedback, we may consider adding action support on other modules like `sc-sast` or `sc-dast` as well. The following commands may be used to manage and run built-in actions:

* `fcli * action list`: List available built-in actions (and imported custom actions, see next section).
* `fcli * action help <action>`: Display action usage information like description and list of action-specific command-line options.
* `fcli * action get <action>`: Display action YAML contents.
* `fcli * action run <action>`: Run a given action.

Note that `fcli * action run <action> -h` will just output the usage help for the `run` command, not for the specified action. You'll need to use the `fcli * action help <action>` command to see action usage help.

=== Custom Actions

Apart from built-in actions, users can also develop and run custom actions, which could be customized versions of built-in actions or completely new actions. The sections below provide more information on custom action usage. For more information on developing custom actions, please refer to the link:action-development.html[Fcli Action Development Guide].

==== Compatibility

Custom actions must specify a schema version, which is used to check compatibility between current fcli version and the provided custom action. Some examples:

* Actions developed for fcli 2.x will fail to run on fcli 3.x (see link:../migration-v2.x-v3.x.html[migration guide])
* Actions developed for fcli 3.0.0 can be run on any future fcli 3.x version, but may fail to run on future fcli 4.x versions
* Actions developed for a later fcli 3.x version may fail to run on earlier fcli 3.x versions

Note that the action schema is versioned independently of fcli. For example, fcli 2.x supports v1.x schema versions, and fcli 3.x supports v2.x schema versions. A future fcli 4.x version may support either v2.x or v3.x schema versions, depending on whether any breaking schema changes are being introduced for fcli 4.x.

==== Loading custom actions

Custom actions can be loaded from various sources, like a local or remote YAML file, optionally embedded in a zip-file that contains multiple actions. Each of the fcli commands listed in the previous section also support custom actions:

* `fcli * action list --from-zip <file|url>`: List available actions from the given zip-file.
* `fcli * action help|get|run <file|url>`: Load the action from the given file or URL.
* `fcli * action help|get|run <action> --from-zip <file|url>`: Load the given action from the given zip-file.

To allow for easy access, custom actions can also be imported into fcli using the `fcli * action import` command, which allows for importing either a single action YAML file or all action YAML files from a local or remote zip-file. Once imported, these actions can be accessed in the same way as built-in actions. Note that imported custom actions will override built-in actions if they have the same name. You can use the `fcli * action reset` command to remove all previously imported custom actions.

=== Security Considerations

As actions can potentially perform dangerous operations, like sending confidential data to third-party systems, or updating or deleting data in Fortify or third-party systems, you should only run trusted actions. If you wish to run any actions provided by a third party, you could potentially review action contents, and potentially in the future we may provide functionality for performing a security analysis on action contents (either as a new fcli command or through Fortify rules). 

However, this won't be sufficient for actions that are dynamically loaded from a remote location, as action contents could change at any time. For example, a legitimate action can easily be replaced by some malicious action.

For this reason, fcli by default requires custom actions to be signed. Organizations, teams or individuals can sign actions with their own private key using the `fcli * action sign` command, the corresponding public key can be imported into fcli using the `fcli config public-key import` command. Most `action` commands also allow for explicitly passing a public key through the `--pubkey` option.

Public keys can be loaded from a local file, URL, string or environment variable, see command help or next section for details. Obviously, you should only use trusted public keys; loading a public key from a third-party URL may be dangerous for the same reasons as explained above.

=== Actions in CI/CD pipelines

Fcli is commonly used in CI/CD pipelines to perform all sorts of Fortify-related operations, and fcli actions allow for even more advanced use cases. This section provides some hints as to how to integrate actions into CI/CD pipelines, considering deployment and security aspects.

*Publishing*

Fcli actions can be loaded from any URL, but for CI/CD integration you could consider hosting custom fcli actions in a shared source code repository like `https://some-scm.our.org/repositories/shared-ci-tools/fcli/actions`. This allows for easy sharing and maintenance of fcli actions that are used across many CI/CD pipelines. This even allows for automatically signing those action using CI/CD pipelines on this shared repository.

*Public & private key management*

Of course, those actions should be signed using an organization-specific private key. For example, this could be either an existing private key that's used throughout the organization, or a private key that's managed by the CI/CD team. There are several ways to pass the corresponding public key to fcli from within CI/CD pipelines:

* Explicitly run `fcli config public-key import` command from each pipeline before running any actions.
* Explicitly pass the `--pubkey` option on any `fcli * action run` commands.
* Set the `FCLI_DEFAULT_PUBKEY` environment variable to configure a default value for the `--pubkey` option.

With each of these approaches, the public key can be be loaded from:

* Local file, for example public key stored in current source code repository.
* URL, for example pointing to public key stored in same shared source code repository as the actions themselves.
* Environment variable, for example defined as system environment variable on self-hosted CI/CD nodes, or configured through (global) CI/CD secrets/variables.
* Plain string, for example having the environment variable `FCLI_DEFAULT_PUBKEY` set to `string:<public key contents>`. You can use CI/CD secrets/variables to set the `FCLI_DEFAULT_PUBKEY` to a value like this. For testing, you can use a `bash` command like the following: `export FCLI_DEFAULT_PUBKEY=string:$(cat my-public.key)`.

== Manual Pages

Manual pages are automatically generated and contain mostly the same information as fcli help output. Manual pages for the current version of this documentation can be accessed here: link:manpage/fcli.html[fcli (1)].

Some important notes:

* Please make sure that you're viewing the correct documentation for the fcli version that you're using:
** When viewing offline documentation (docs-html.zip downloaded from fcli releases page), make sure that you downloaded the correct version.
** When viewing online documentation at fortify.github.io, make sure that the drop-down menu on the top-right is showing the correct fcli version.
* If you are viewing an offline copy of this documentation, the manual pages link above will likely only work if you extracted the full zip-file to a local directory.
* In some cases, fcli help output may show more details than the manual pages, if those details are only available at runtime. 
** A notable example are the various states that may be referenced in `+wait-for+` commands; these states are not listed in the manual pages but can be viewed by running `+fcli <product> <entity> wait-for -h+`.

== Troubleshooting

=== Native Binaries

Native binaries require some special source code annotations for proper operation, which are not required for the plain Java `+.jar+` version of fcli. If fcli developers forgot to include any of these annotations, you
may experience any of the following behavior:

* Commands and/or option listed in manual pages are not listed by the help output of a native binary
* Trying to use commands and/or options listed in the manual pages result in errors stating that the command or option is not recognized
* Some commands and/or options result in technical error messages about classes, constructors or methods not being found or not being accessible

If you encounter any of these issues, please submit a bug report as described in link:#_submitting_a_bug_report[Submitting a Bug Report]. As described in that section, please include information on whether the `+.jar+` version of fcli exhibits the same erroneous behavior. While fcli developers are working on fixing the issue, you can temporarily use the `+.jar+` version of fcli until the issue is resolved.

=== Submitting a Bug Report

After confirming that an issue cannot be resolved based on the information above, and is not caused by user error, please consider submitting a bug report. Before doing so, please verify that there is not already a bug report open for the issue that you are experiencing on the https://github.com/fortify/fcli/issues[fcli issue tracker on GitHub]. If an issue already exists, please consider posting a comment on the existing bug report to confirm the issue and/or provide additional details.

If needed, you can submit a bug report through any of the following channels:

* https://github.com/fortify/fcli/issues[fcli issue tracker on GitHub]; if you have a GitHub account, this is likely the easiest approach, and allows for all fcli contributors to review & comment on your bug report. Please note though that any information posted here is publicly accessible.
* Through your OpenText Fortify Customer Success Manager or Technical Account Manager
* Through the regular Fortify Support channels

When opening a bug report, please include the following information:

* Fcli version, as shown by the `+fcli --version+` command
* Which fcli variant you are using; one of the native binaries or the `+.jar+` variant invoked using `+java -jar fcli.jar+`
* If you are experiencing an issue with the native binaries, please confirm whether the `+.jar+` version of fcli exhibits the same behavior
* Operating system and any other relevant environment details, for example:
** Interactive or pipeline/automation use
** If pipeline use, what CI/CD system are you running fcli on (Jenkins, GitHub, GitLab, …)
** What FCLI environment variables have been set
* Steps to reproduce
* Any other information that may be relevant
